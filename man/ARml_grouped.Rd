% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/arml_grouped.R
\name{ARml_grouped}
\alias{ARml_grouped}
\title{Forecasting grouped time series using caret}
\usage{
ARml_grouped(
  data,
  outcome_col_name,
  date_col = 1,
  horizons = c(1, 6, 12),
  lookback = c(1:5),
  frequency = "1 month",
  groups = NULL,
  dynamic_features = c("month", "year", "week", "day", "quarter"),
  static_features = NULL,
  train_control = caret::trainControl(method = "cv", number = 3, p = 0.75, search =
    "grid", selectionFunction = "best", verboseIter = T, trim = FALSE, allowParallel =
    FALSE),
  ncore = 2,
  tune_grid = NULL,
  pre_process = NULL,
  weights = NULL,
  caret_method = "lm",
  metric = "RMSE",
  return_model = TRUE,
  return_input_data = FALSE,
  return_all_horizon_forecast = FALSE,
  return_fitted_values = TRUE,
  set_seed = 42
)
}
\arguments{
\item{data}{A grouped time series class of data.frame}

\item{outcome_col_name}{Names of the output column}

\item{date_col}{An integer indicating the location of the date column}

\item{horizons}{A numeric vector of one or more forecast horizons, h,
measured in dataset rows.If dates are given, a horizon of 1, for example,
would equal 1 * frequency in calendar time.}

\item{lookback}{A numeric vector giving the lags–in dataset rows–for creating
the lagged features.
All non-grouping, non-static, and non-dynamic features in the input dataset,
data, are lagged by the same values.
The outcome is also lagged by default. Either lookback or lookback_control
need to be specified–but not both.}

\item{frequency}{Date/time frequency. Required if dates are given.
A string taking the same input as base::seq.Date(..., by = "frequency") or
base::seq.POSIXt(..., by = "frequency") e.g., '1 hour', '1 month', '7 days',
'10 years' etc.
The highest frequency supported at present is '1 sec'.}

\item{groups}{A character vector of column names that identify
the groups/hierarchies when multiple time series are present.
These columns are used as model features but are not lagged.
Note that combining feature lags with grouped time series will result in
NA values throughout the data.}

\item{dynamic_features}{A character vector to define date features, "month",
"year", "week", "day", "quarter" are supported features.}

\item{static_features}{For grouped time series only.
A character vector of column names that identify features that do not change
through time.
These columns are not lagged.
If type = "forecast", these features will be filled forward using the
most recent value for the group.}

\item{train_control}{Control parameters for caret train see
\code{\link[caret]{trainControl}}}

\item{ncore}{If \code{allowParallel = TRUE} in
\code{\link[caret]{trainControl}}
user can specify number of cores to be used.}

\item{tune_grid}{A data frame with possible tuning values.
The columns are named the same as the tuning parameters.
Use getModelInfo to get a list of tuning parameters for each model or see
\url{http://topepo.github.io/caret/available-models.html}.
(NOTE: If given, this argument must be named.)}

\item{pre_process}{A string vector that defines a pre-processing of the
predictor data.
Current possibilities are "BoxCox", "YeoJohnson", "expoTrans", "center",
"scale", "range",
"knnImpute", "bagImpute", "medianImpute", "pca", "ica" and "spatialSign".
The default is no pre-processing.
See preProcess and trainControl on the procedures and how to adjust them.
Pre-processing code is only designed to work when x is a simple matrix or
data frame.}

\item{weights}{A numeric vector of case weights.
This argument will only affect models that allow case weights.}

\item{caret_method}{A string (or a self defined model list see
\url{http://topepo.github.io/caret/using-your-own-model-in-train.html})
specifying which classification or regression model to use.
Possible values are found using names(getModelInfo()).
See  \url{http://topepo.github.io/caret/train-models-by-tag.html}.
A list of functions can also be passed for a custom model function.
See \url{http://topepo.github.io/caret/using-your-own-model-in-train.html}
for details.}

\item{metric}{A string that specifies what summary metric will be used to
select the optimal model.
By default, possible values are "RMSE" and "Rsquared" for regression and
"Accuracy" and "Kappa" for classification.
If custom performance metrics are used (via the summaryFunction argument in
trainControl, the value of metric should match one of the arguments.
If it does not, a warning is issued and the first metric given by the
summaryFunction is used.
(NOTE: If given, this argument must be named.)}

\item{return_model}{Boolean. If \code{TRUE} trained model will be returned.}

\item{return_input_data}{Boolean. If \code{TRUE} input data will be returned.}

\item{return_all_horizon_forecast}{Boolean. If \code{TRUE} forecast
from all horizon forecast  will be returned.}

\item{return_fitted_values}{Boolean. If \code{TRUE}fitted values will be
returned.}

\item{set_seed}{set random number generation}
}
\description{
\Sexpr[results=rd, stage=render]{lifecycle::badge("experimental")}

Forecasting grouped time series using caret
}
\examples{
 \dontrun{

data(retail, package = "MLforecast")

fc <- ARml_grouped(retail, outcome_col_name = "value",
                  date_col = 1,
                  horizons = c(1, 9, 18),
                  lookback = c(1:24),
                  frequency = "1 month",
                  groups = "items",
                  dynamic_features = c("month", "year", "quarter"),
                  caret_method = "cubist",
                  return_model = F,
                 return_input_data = F,
                  return_all_horizon_forecast = TRUE,
                  return_fitted_values = TRUE)



plot(fc$fitted_values, group_filter = "items == 'V10'")

plot(fc$combined_forecasts, data_actual = retail,
    actual_indices = retail$date, group_filter = "items == 'V3'")
}




}
\author{
Res Akay
}
